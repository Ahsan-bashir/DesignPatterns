# Structural Patterns 

Structural design patterns focus on how classes and objects are composed to form larger structures. They provide flexibility, reusability, and help in managing the relationships between objects.

## Pros

- **Flexibility**: Structural patterns allow for flexible composition of objects and classes, making it easier to adapt to changing requirements.
- **Reusability**: They promote reusability of code by defining clear interfaces and separations of concerns.
- **Encapsulation**: Structural patterns help in encapsulating implementation details, promoting better code organization and maintainability.

## Cons

- **Complexity**: Some structural patterns can introduce complexity, especially when dealing with a large number of classes or when used improperly.
- **Overhead**: Certain patterns may introduce overhead, such as additional memory usage or performance penalties.
- **Learning Curve**: Understanding and implementing structural patterns may require additional learning and experience.

## Practical Use (Types of Structural Patterns)

- **Adapter Pattern**: Useful for integrating incompatible interfaces or systems, such as when working with legacy code or third-party libraries.
- **Decorator Pattern**: Practical for adding or extending functionality to objects dynamically, without modifying their underlying code.
- **Proxy Pattern**: Used for controlling access to objects or adding additional functionality, such as logging or access control.
- **Bridge Pattern**: Useful when you need to decouple an abstraction from its implementation, allowing them to vary independently.
- **Composite Pattern**: Practical for representing part-whole hierarchies and treating individual objects and compositions uniformly.
- **Flyweight Pattern**: Useful for minimizing memory usage or computational expenses by sharing resources among similar objects.
- **Facade Pattern**: Practical for providing a simplified interface to a complex subsystem, hiding its complexities from clients.

